'use strict';

var cst = require('./cst.js');

/*
START -> stream

stream
  directive -> line-end -> stream
  indent + line-end -> stream
  [else] -> line-start

line-end
  comment -> line-end
  newline -> .
  input-end -> END

line-start
  doc-start -> doc
  doc-end -> stream
  [else] -> indent -> block-start

block-start
  seq-item-start -> block-start
  explicit-key-start -> block-start
  map-value-start -> block-start
  [else] -> doc

doc
  line-end -> line-start
  spaces -> doc
  anchor -> doc
  tag -> doc
  flow-start -> flow -> doc
  flow-end -> error -> doc
  seq-item-start -> error -> doc
  explicit-key-start -> error -> doc
  map-value-start -> doc
  alias -> doc
  quote-start -> quoted-scalar -> doc
  block-scalar-header -> line-end -> block-scalar(min) -> line-start
  [else] -> plain-scalar(false, min) -> doc

flow
  line-end -> flow
  spaces -> flow
  anchor -> flow
  tag -> flow
  flow-start -> flow -> flow
  flow-end -> .
  seq-item-start -> error -> flow
  explicit-key-start -> flow
  map-value-start -> flow
  alias -> flow
  quote-start -> quoted-scalar -> flow
  comma -> flow
  [else] -> plain-scalar(true, 0) -> flow

quoted-scalar
  quote-end -> .
  [else] -> quoted-scalar

block-scalar(min)
  newline + peek(indent < min) -> .
  [else] -> block-scalar(min)

plain-scalar(is-flow, min)
  scalar-end(is-flow) -> .
  peek(newline + (indent < min)) -> .
  [else] -> plain-scalar(min)
*/
function isEmpty(ch) {
    switch (ch) {
        case undefined:
        case ' ':
        case '\n':
        case '\r':
        case '\t':
            return true;
        default:
            return false;
    }
}
const hexDigits = '0123456789ABCDEFabcdef'.split('');
const tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split('');
const invalidFlowScalarChars = ',[]{}'.split('');
const invalidAnchorChars = ' ,[]{}\n\r\t'.split('');
const isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
/**
 * Splits an input string into lexical tokens, i.e. smaller strings that are
 * easily identifiable by `tokens.tokenType()`.
 *
 * Lexing starts always in a "stream" context. Incomplete input may be buffered
 * until a complete token can be emitted.
 *
 * In addition to slices of the original input, the following control characters
 * may also be emitted:
 *
 * - `\x02` (Start of Text): A document starts with the next token
 * - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
 * - `\x1f` (Unit Separator): Next token is a scalar value
 * - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
 */
class Lexer {
    constructor() {
        /**
         * Flag indicating whether the end of the current buffer marks the end of
         * all input
         */
        this.atEnd = false;
        /**
         * Explicit indent set in block scalar header, as an offset from the current
         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
         * explicitly set.
         */
        this.blockScalarIndent = -1;
        /**
         * Block scalars that include a + (keep) chomping indicator in their header
         * include trailing empty lines, which are otherwise excluded from the
         * scalar's contents.
         */
        this.blockScalarKeep = false;
        /** Current input */
        this.buffer = '';
        /**
         * Flag noting whether the map value indicator : can immediately follow this
         * node within a flow context.
         */
        this.flowKey = false;
        /** Count of surrounding flow collection levels. */
        this.flowLevel = 0;
        /**
         * Minimum level of indentation required for next lines to be parsed as a
         * part of the current scalar value.
         */
        this.indentNext = 0;
        /** Indentation level of the current line. */
        this.indentValue = 0;
        /** Position of the next \n character. */
        this.lineEndPos = null;
        /** Stores the state of the lexer if reaching the end of incpomplete input */
        this.next = null;
        /** A pointer to `buffer`; the current position of the lexer. */
        this.pos = 0;
    }
    /**
     * Generate YAML tokens from the `source` string. If `incomplete`,
     * a part of the last line may be left as a buffer for the next call.
     *
     * @returns A generator of lexical tokens
     */
    *lex(source, incomplete = false) {
        if (source) {
            this.buffer = this.buffer ? this.buffer + source : source;
            this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? 'stream';
        while (next && (incomplete || this.hasChars(1)))
            next = yield* this.parseNext(next);
    }
    atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === ' ' || ch === '\t')
            ch = this.buffer[++i];
        if (!ch || ch === '#' || ch === '\n')
            return true;
        if (ch === '\r')
            return this.buffer[i + 1] === '\n';
        return false;
    }
    charAt(n) {
        return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
            let indent = 0;
            while (ch === ' ')
                ch = this.buffer[++indent + offset];
            if (ch === '\r') {
                const next = this.buffer[indent + offset + 1];
                if (next === '\n' || (!next && !this.atEnd))
                    return offset + indent + 1;
            }
            return ch === '\n' || indent >= this.indentNext || (!ch && !this.atEnd)
                ? offset + indent
                : -1;
        }
        if (ch === '-' || ch === '.') {
            const dt = this.buffer.substr(offset, 3);
            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))
                return -1;
        }
        return offset;
    }
    getLine() {
        let end = this.lineEndPos;
        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {
            end = this.buffer.indexOf('\n', this.pos);
            this.lineEndPos = end;
        }
        if (end === -1)
            return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === '\r')
            end -= 1;
        return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
        return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
    }
    peek(n) {
        return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
        switch (next) {
            case 'stream':
                return yield* this.parseStream();
            case 'line-start':
                return yield* this.parseLineStart();
            case 'block-start':
                return yield* this.parseBlockStart();
            case 'doc':
                return yield* this.parseDocument();
            case 'flow':
                return yield* this.parseFlowCollection();
            case 'quoted-scalar':
                return yield* this.parseQuotedScalar();
            case 'block-scalar':
                return yield* this.parseBlockScalar();
            case 'plain-scalar':
                return yield* this.parsePlainScalar();
        }
    }
    *parseStream() {
        let line = this.getLine();
        if (line === null)
            return this.setNext('stream');
        if (line[0] === cst.BOM) {
            yield* this.pushCount(1);
            line = line.substring(1);
        }
        if (line[0] === '%') {
            let dirEnd = line.length;
            const cs = line.indexOf('#');
            if (cs !== -1) {
                const ch = line[cs - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd = cs - 1;
            }
            while (true) {
                const ch = line[dirEnd - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd -= 1;
                else
                    break;
            }
            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
            yield* this.pushCount(line.length - n); // possible comment
            this.pushNewline();
            return 'stream';
        }
        if (this.atLineEnd()) {
            const sp = yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - sp);
            yield* this.pushNewline();
            return 'stream';
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
    }
    *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
            return this.setNext('line-start');
        if (ch === '-' || ch === '.') {
            if (!this.atEnd && !this.hasChars(4))
                return this.setNext('line-start');
            const s = this.peek(3);
            if (s === '---' && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                this.indentValue = 0;
                this.indentNext = 0;
                return 'doc';
            }
            else if (s === '...' && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                return 'stream';
            }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
            this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
            return this.setNext('block-start');
        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {
            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
            this.indentNext = this.indentValue + 1;
            this.indentValue += n;
            return yield* this.parseBlockStart();
        }
        return 'doc';
    }
    *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
            return this.setNext('doc');
        let n = yield* this.pushIndicators();
        switch (line[n]) {
            case '#':
                yield* this.pushCount(line.length - n);
            // fallthrough
            case undefined:
                yield* this.pushNewline();
                return yield* this.parseLineStart();
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel = 1;
                return 'flow';
            case '}':
            case ']':
                // this is an error
                yield* this.pushCount(1);
                return 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'doc';
            case '"':
            case "'":
                return yield* this.parseQuotedScalar();
            case '|':
            case '>':
                n += yield* this.parseBlockScalarHeader();
                n += yield* this.pushSpaces(true);
                yield* this.pushCount(line.length - n);
                yield* this.pushNewline();
                return yield* this.parseBlockScalar();
            default:
                return yield* this.parsePlainScalar();
        }
    }
    *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
            nl = yield* this.pushNewline();
            if (nl > 0) {
                sp = yield* this.pushSpaces(false);
                this.indentValue = indent = sp;
            }
            else {
                sp = 0;
            }
            sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
            return this.setNext('flow');
        if ((indent !== -1 && indent < this.indentNext && line[0] !== '#') ||
            (indent === 0 &&
                (line.startsWith('---') || line.startsWith('...')) &&
                isEmpty(line[3]))) {
            // Allowing for the terminal ] or } at the same (rather than greater)
            // indent level as the initial [ or { is technically invalid, but
            // failing here would be surprising to users.
            const atFlowEndMarker = indent === this.indentNext - 1 &&
                this.flowLevel === 1 &&
                (line[0] === ']' || line[0] === '}');
            if (!atFlowEndMarker) {
                // this is an error
                this.flowLevel = 0;
                yield cst.FLOW_END;
                return yield* this.parseLineStart();
            }
        }
        let n = 0;
        while (line[n] === ',') {
            n += yield* this.pushCount(1);
            n += yield* this.pushSpaces(true);
            this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
            case undefined:
                return 'flow';
            case '#':
                yield* this.pushCount(line.length - n);
                return 'flow';
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel += 1;
                return 'flow';
            case '}':
            case ']':
                yield* this.pushCount(1);
                this.flowKey = true;
                this.flowLevel -= 1;
                return this.flowLevel ? 'flow' : 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'flow';
            case '"':
            case "'":
                this.flowKey = true;
                return yield* this.parseQuotedScalar();
            case ':': {
                const next = this.charAt(1);
                if (this.flowKey || isEmpty(next) || next === ',') {
                    this.flowKey = false;
                    yield* this.pushCount(1);
                    yield* this.pushSpaces(true);
                    return 'flow';
                }
            }
            // fallthrough
            default:
                this.flowKey = false;
                return yield* this.parsePlainScalar();
        }
    }
    *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
            while (end !== -1 && this.buffer[end + 1] === "'")
                end = this.buffer.indexOf("'", end + 2);
        }
        else {
            // double-quote
            while (end !== -1) {
                let n = 0;
                while (this.buffer[end - 1 - n] === '\\')
                    n += 1;
                if (n % 2 === 0)
                    break;
                end = this.buffer.indexOf('"', end + 1);
            }
        }
        // Only looking for newlines within the quotes
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf('\n', this.pos);
        if (nl !== -1) {
            while (nl !== -1) {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = qb.indexOf('\n', cs);
            }
            if (nl !== -1) {
                // this is an error caused by an unexpected unindent
                end = nl - (qb[nl - 1] === '\r' ? 2 : 1);
            }
        }
        if (end === -1) {
            if (!this.atEnd)
                return this.setNext('quoted-scalar');
            end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? 'flow' : 'doc';
    }
    *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
            const ch = this.buffer[++i];
            if (ch === '+')
                this.blockScalarKeep = true;
            else if (ch > '0' && ch <= '9')
                this.blockScalarIndent = Number(ch) - 1;
            else if (ch !== '-')
                break;
        }
        return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');
    }
    *parseBlockScalar() {
        let nl = this.pos - 1; // may be -1 if this.pos === 0
        let indent = 0;
        let ch;
        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {
            switch (ch) {
                case ' ':
                    indent += 1;
                    break;
                case '\n':
                    nl = i;
                    indent = 0;
                    break;
                case '\r': {
                    const next = this.buffer[i + 1];
                    if (!next && !this.atEnd)
                        return this.setNext('block-scalar');
                    if (next === '\n')
                        break;
                } // fallthrough
                default:
                    break loop;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('block-scalar');
        if (indent >= this.indentNext) {
            if (this.blockScalarIndent === -1)
                this.indentNext = indent;
            else
                this.indentNext += this.blockScalarIndent;
            do {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = this.buffer.indexOf('\n', cs);
            } while (nl !== -1);
            if (nl === -1) {
                if (!this.atEnd)
                    return this.setNext('block-scalar');
                nl = this.buffer.length;
            }
        }
        if (!this.blockScalarKeep) {
            do {
                let i = nl - 1;
                let ch = this.buffer[i];
                if (ch === '\r')
                    ch = this.buffer[--i];
                const lastChar = i; // Drop the line if last char not more indented
                while (ch === ' ' || ch === '\t')
                    ch = this.buffer[--i];
                if (ch === '\n' && i >= this.pos && i + 1 + indent > lastChar)
                    nl = i;
                else
                    break;
            } while (true);
        }
        yield cst.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while ((ch = this.buffer[++i])) {
            if (ch === ':') {
                const next = this.buffer[i + 1];
                if (isEmpty(next) || (inFlow && next === ','))
                    break;
                end = i;
            }
            else if (isEmpty(ch)) {
                let next = this.buffer[i + 1];
                if (ch === '\r') {
                    if (next === '\n') {
                        i += 1;
                        ch = '\n';
                        next = this.buffer[i + 1];
                    }
                    else
                        end = i;
                }
                if (next === '#' || (inFlow && invalidFlowScalarChars.includes(next)))
                    break;
                if (ch === '\n') {
                    const cs = this.continueScalar(i + 1);
                    if (cs === -1)
                        break;
                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'
                }
            }
            else {
                if (inFlow && invalidFlowScalarChars.includes(ch))
                    break;
                end = i;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('plain-scalar');
        yield cst.SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? 'flow' : 'doc';
    }
    *pushCount(n) {
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos += n;
            return n;
        }
        return 0;
    }
    *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
            yield s;
            this.pos += s.length;
            return s.length;
        }
        else if (allowEmpty)
            yield '';
        return 0;
    }
    *pushIndicators() {
        switch (this.charAt(0)) {
            case '!':
                return ((yield* this.pushTag()) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case '&':
                return ((yield* this.pushUntil(isNotAnchorChar)) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case '-': // this is an error
            case '?': // this is an error outside flow collections
            case ':': {
                const inFlow = this.flowLevel > 0;
                const ch1 = this.charAt(1);
                if (isEmpty(ch1) || (inFlow && invalidFlowScalarChars.includes(ch1))) {
                    if (!inFlow)
                        this.indentNext = this.indentValue + 1;
                    else if (this.flowKey)
                        this.flowKey = false;
                    return ((yield* this.pushCount(1)) +
                        (yield* this.pushSpaces(true)) +
                        (yield* this.pushIndicators()));
                }
            }
        }
        return 0;
    }
    *pushTag() {
        if (this.charAt(1) === '<') {
            let i = this.pos + 2;
            let ch = this.buffer[i];
            while (!isEmpty(ch) && ch !== '>')
                ch = this.buffer[++i];
            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);
        }
        else {
            let i = this.pos + 1;
            let ch = this.buffer[i];
            while (ch) {
                if (tagChars.includes(ch))
                    ch = this.buffer[++i];
                else if (ch === '%' &&
                    hexDigits.includes(this.buffer[i + 1]) &&
                    hexDigits.includes(this.buffer[i + 2])) {
                    ch = this.buffer[(i += 3)];
                }
                else
                    break;
            }
            return yield* this.pushToIndex(i, false);
        }
    }
    *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === '\n')
            return yield* this.pushCount(1);
        else if (ch === '\r' && this.charAt(1) === '\n')
            return yield* this.pushCount(2);
        else
            return 0;
    }
    *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
            ch = this.buffer[++i];
        } while (ch === ' ' || (allowTabs && ch === '\t'));
        const n = i - this.pos;
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos = i;
        }
        return n;
    }
    *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
            ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
    }
}

exports.Lexer = Lexer;

// SIG // Begin signature block
// SIG // MIIoaAYJKoZIhvcNAQcCoIIoWTCCKFUCAQExDzANBglg
// SIG // hkgBZQMEAgEFADB3BgorBgEEAYI3AgEEoGkwZzAyBgor
// SIG // BgEEAYI3AgEeMCQCAQEEEBDgyQbOONQRoqMAEEvTUJAC
// SIG // AQACAQACAQACAQACAQAwMTANBglghkgBZQMEAgEFAAQg
// SIG // LEFGsFQ9hTNEBZF7WJZjK3ml7I3OIqJ42tAir1cMjceg
// SIG // gg2aMIIGGDCCBACgAwIBAgITMwAAA/O5amS77/ftYwAA
// SIG // AAAD8zANBgkqhkiG9w0BAQsFADB+MQswCQYDVQQGEwJV
// SIG // UzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMH
// SIG // UmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBv
// SIG // cmF0aW9uMSgwJgYDVQQDEx9NaWNyb3NvZnQgQ29kZSBT
// SIG // aWduaW5nIFBDQSAyMDExMB4XDTI0MDcxNzIxMDIzNFoX
// SIG // DTI1MDkxNTIxMDIzNFowgYgxCzAJBgNVBAYTAlVTMRMw
// SIG // EQYDVQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQHEwdSZWRt
// SIG // b25kMR4wHAYDVQQKExVNaWNyb3NvZnQgQ29ycG9yYXRp
// SIG // b24xMjAwBgNVBAMTKU1pY3Jvc29mdCAzcmQgUGFydHkg
// SIG // QXBwbGljYXRpb24gQ29tcG9uZW50MIIBIjANBgkqhkiG
// SIG // 9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuJZyYTUkf/jOL2+w
// SIG // jAIr0zGEmBItBJx10kg2rf/QcDw9otBdYY+1vNFvHRLp
// SIG // b+dX89TQCCym3iKdiWku++5n32B38TFMPwXELMs1uidX
// SIG // ucVDzYLhlNhhV63ObPo8it/QCKROgE2XnIzA7gLuD9Z1
// SIG // RHGSg0dHwWz+0PAhXtdz4J2Yt5/+FF28GhJbxZK8ImuM
// SIG // IfPICfu5QxZGVDiNR9ccRDYD/cti5Qon6xzmoQF3GPk2
// SIG // ksnmar/hNI1eUpAavMzRQnlsjG6KCTz7Ehvi0BH0trDu
// SIG // MTazR2TJSYs4le/YddqsS4nD3rMLoDXQ/mgV6hdH8KKL
// SIG // z7r0sGik/8DPKJDTMQIDAQABo4IBgjCCAX4wHwYDVR0l
// SIG // BBgwFgYKKwYBBAGCN0wRAQYIKwYBBQUHAwMwHQYDVR0O
// SIG // BBYEFNUXbIMP3Uc+qArjvLCjbK6HZhMPMFQGA1UdEQRN
// SIG // MEukSTBHMS0wKwYDVQQLEyRNaWNyb3NvZnQgSXJlbGFu
// SIG // ZCBPcGVyYXRpb25zIExpbWl0ZWQxFjAUBgNVBAUTDTIz
// SIG // MTUyMis1MDI1MjEwHwYDVR0jBBgwFoAUSG5k5VAF04Kq
// SIG // Fzc3IrVtqMp1ApUwVAYDVR0fBE0wSzBJoEegRYZDaHR0
// SIG // cDovL3d3dy5taWNyb3NvZnQuY29tL3BraW9wcy9jcmwv
// SIG // TWljQ29kU2lnUENBMjAxMV8yMDExLTA3LTA4LmNybDBh
// SIG // BggrBgEFBQcBAQRVMFMwUQYIKwYBBQUHMAKGRWh0dHA6
// SIG // Ly93d3cubWljcm9zb2Z0LmNvbS9wa2lvcHMvY2VydHMv
// SIG // TWljQ29kU2lnUENBMjAxMV8yMDExLTA3LTA4LmNydDAM
// SIG // BgNVHRMBAf8EAjAAMA0GCSqGSIb3DQEBCwUAA4ICAQBj
// SIG // RShosExjVPOZfvN7SYQejdgT72k/UwJLhO7lJ4rtVVOm
// SIG // 9f3q3JJl4rlagS4NrBsxOztdtmyvO9XzVqYhK/f6TH5W
// SIG // odTy//tA+lwqHVkuNVJliC0VIUqilEWfonHquZ+BFIin
// SIG // GqQSoWergil0l+tglR5bzb+DeiQOzVM7RNId4wBEHi6B
// SIG // khZXzar5EzqGxOTcJTEUiVoUOkmJ7MIk2NUFNOqUk2j/
// SIG // 3lXnS0ZOqt7f1PYm71cB0/nk8NQEgW2aGTsVgNxY6yvV
// SIG // 4rDk/xqMldsPQ94MyhRjhJQhaUb3HhnkSstjd2EkY44F
// SIG // fVWJVDORv3M+GYoAArZ3eI3xO3m2ypog79lAdSFKcUs0
// SIG // uEwDtW5ADW8Cf3630opFDxn2Utn0UVzFmU3kC+W0wXJl
// SIG // uyDTUyMTNjMRekKpS7ZpCWd4r/XKHMENTM1q63dQVP4q
// SIG // S8IBrW8O5gnrLV2Yz9mphXkI7nALSrfT5BDZ1n1Hsa8E
// SIG // GZ2SVhd5glbyU4egAlNAicjtGtmvkYrsbL0fEKTMNYBN
// SIG // ++OEmzO+ZwAbvOP83ZMX0ZIl66OSLFCfnjVV1ShJbxZ4
// SIG // Ac6W2LU1X9T3XLPMtLBKOhcRkJM8CjSx3tvLRtR9zUx1
// SIG // DWtC0FCkYzKv+fCGr/aquK1tUCM31wBJwQ0gRb9ROLy5
// SIG // sdi4IajET8kwAWbq6wgp9TCCB3owggVioAMCAQICCmEO
// SIG // kNIAAAAAAAMwDQYJKoZIhvcNAQELBQAwgYgxCzAJBgNV
// SIG // BAYTAlVTMRMwEQYDVQQIEwpXYXNoaW5ndG9uMRAwDgYD
// SIG // VQQHEwdSZWRtb25kMR4wHAYDVQQKExVNaWNyb3NvZnQg
// SIG // Q29ycG9yYXRpb24xMjAwBgNVBAMTKU1pY3Jvc29mdCBS
// SIG // b290IENlcnRpZmljYXRlIEF1dGhvcml0eSAyMDExMB4X
// SIG // DTExMDcwODIwNTkwOVoXDTI2MDcwODIxMDkwOVowfjEL
// SIG // MAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24x
// SIG // EDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jv
// SIG // c29mdCBDb3Jwb3JhdGlvbjEoMCYGA1UEAxMfTWljcm9z
// SIG // b2Z0IENvZGUgU2lnbmluZyBQQ0EgMjAxMTCCAiIwDQYJ
// SIG // KoZIhvcNAQEBBQADggIPADCCAgoCggIBAKvw+nIQHC6t
// SIG // 2G6qghBNNLrytlghn0IbKmvpWlCquAY4GgRJun/DDB7d
// SIG // N2vGEtgL8DjCmQawyDnVARQxQtOJDXlkh36UYCRsr55J
// SIG // nOloXtLfm1OyCizDr9mpK656Ca/XllnKYBoF6WZ26DJS
// SIG // JhIv56sIUM+zRLdd2MQuA3WraPPLbfM6XKEW9Ea64Dhk
// SIG // rG5kNXimoGMPLdNAk/jj3gcN1Vx5pUkp5w2+oBN3vpQ9
// SIG // 7/vjK1oQH01WKKJ6cuASOrdJXtjt7UORg9l7snuGG9k+
// SIG // sYxd6IlPhBryoS9Z5JA7La4zWMW3Pv4y07MDPbGyr5I4
// SIG // ftKdgCz1TlaRITUlwzluZH9TupwPrRkjhMv0ugOGjfdf
// SIG // 8NBSv4yUh7zAIXQlXxgotswnKDglmDlKNs98sZKuHCOn
// SIG // qWbsYR9q4ShJnV+I4iVd0yFLPlLEtVc/JAPw0XpbL9Uj
// SIG // 43BdD1FGd7P4AOG8rAKCX9vAFbO9G9RVS+c5oQ/pI0m8
// SIG // GLhEfEXkwcNyeuBy5yTfv0aZxe/CHFfbg43sTUkwp6uO
// SIG // 3+xbn6/83bBm4sGXgXvt1u1L50kppxMopqd9Z4DmimJ4
// SIG // X7IvhNdXnFy/dygo8e1twyiPLI9AN0/B4YVEicQJTMXU
// SIG // pUMvdJX3bvh4IFgsE11glZo+TzOE2rCIF96eTvSWsLxG
// SIG // oGyY0uDWiIwLAgMBAAGjggHtMIIB6TAQBgkrBgEEAYI3
// SIG // FQEEAwIBADAdBgNVHQ4EFgQUSG5k5VAF04KqFzc3IrVt
// SIG // qMp1ApUwGQYJKwYBBAGCNxQCBAweCgBTAHUAYgBDAEEw
// SIG // CwYDVR0PBAQDAgGGMA8GA1UdEwEB/wQFMAMBAf8wHwYD
// SIG // VR0jBBgwFoAUci06AjGQQ7kUBU7h6qfHMdEjiTQwWgYD
// SIG // VR0fBFMwUTBPoE2gS4ZJaHR0cDovL2NybC5taWNyb3Nv
// SIG // ZnQuY29tL3BraS9jcmwvcHJvZHVjdHMvTWljUm9vQ2Vy
// SIG // QXV0MjAxMV8yMDExXzAzXzIyLmNybDBeBggrBgEFBQcB
// SIG // AQRSMFAwTgYIKwYBBQUHMAKGQmh0dHA6Ly93d3cubWlj
// SIG // cm9zb2Z0LmNvbS9wa2kvY2VydHMvTWljUm9vQ2VyQXV0
// SIG // MjAxMV8yMDExXzAzXzIyLmNydDCBnwYDVR0gBIGXMIGU
// SIG // MIGRBgkrBgEEAYI3LgMwgYMwPwYIKwYBBQUHAgEWM2h0
// SIG // dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9wa2lvcHMvZG9j
// SIG // cy9wcmltYXJ5Y3BzLmh0bTBABggrBgEFBQcCAjA0HjIg
// SIG // HQBMAGUAZwBhAGwAXwBwAG8AbABpAGMAeQBfAHMAdABh
// SIG // AHQAZQBtAGUAbgB0AC4gHTANBgkqhkiG9w0BAQsFAAOC
// SIG // AgEAZ/KGpZjgVHkaLtPYdGcimwuWEeFjkplCln3SeQyQ
// SIG // wWVfLiw++MNy0W2D/r4/6ArKO79HqaPzadtjvyI1pZdd
// SIG // ZYSQfYtGUFXYDJJ80hpLHPM8QotS0LD9a+M+By4pm+Y9
// SIG // G6XUtR13lDni6WTJRD14eiPzE32mkHSDjfTLJgJGKsKK
// SIG // ELukqQUMm+1o+mgulaAqPyprWEljHwlpblqYluSD9MCP
// SIG // 80Yr3vw70L01724lruWvJ+3Q3fMOr5kol5hNDj0L8giJ
// SIG // 1h/DMhji8MUtzluetEk5CsYKwsatruWy2dsViFFFWDgy
// SIG // cScaf7H0J/jeLDogaZiyWYlobm+nt3TDQAUGpgEqKD6C
// SIG // PxNNZgvAs0314Y9/HG8VfUWnduVAKmWjw11SYobDHWM2
// SIG // l4bf2vP48hahmifhzaWX0O5dY0HjWwechz4GdwbRBrF1
// SIG // HxS+YWG18NzGGwS+30HHDiju3mUv7Jf2oVyW2ADWoUa9
// SIG // WfOXpQlLSBCZgB/QACnFsZulP0V3HjXG0qKin3p6IvpI
// SIG // lR+r+0cjgPWe+L9rt0uX4ut1eBrs6jeZeRhL/9azI2h1
// SIG // 5q/6/IvrC4DqaTuv/DDtBEyO3991bWORPdGdVk5Pv4BX
// SIG // IqF4ETIheu9BCrE/+6jMpF3BoYibV3FWTkhFwELJm3Zb
// SIG // CoBIa/15n8G9bW1qyVJzEw16UM0xghomMIIaIgIBATCB
// SIG // lTB+MQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGlu
// SIG // Z3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMV
// SIG // TWljcm9zb2Z0IENvcnBvcmF0aW9uMSgwJgYDVQQDEx9N
// SIG // aWNyb3NvZnQgQ29kZSBTaWduaW5nIFBDQSAyMDExAhMz
// SIG // AAAD87lqZLvv9+1jAAAAAAPzMA0GCWCGSAFlAwQCAQUA
// SIG // oIGuMBkGCSqGSIb3DQEJAzEMBgorBgEEAYI3AgEEMBwG
// SIG // CisGAQQBgjcCAQsxDjAMBgorBgEEAYI3AgEVMC8GCSqG
// SIG // SIb3DQEJBDEiBCAIiskAhXHCS9cVak1hMmtA9+sjwhXn
// SIG // TOzhK4EWE7eKCDBCBgorBgEEAYI3AgEMMTQwMqAUgBIA
// SIG // TQBpAGMAcgBvAHMAbwBmAHShGoAYaHR0cDovL3d3dy5t
// SIG // aWNyb3NvZnQuY29tMA0GCSqGSIb3DQEBAQUABIIBAC0N
// SIG // Gxi8joYdNJKWrssNwq/wmsq/tJrdH09n7C4CdqzurYf6
// SIG // 1eXUBU9CQV+NvVBHCcc7iYApopz1QiK7iDSUESpT0m+S
// SIG // S45etWx+mjcvLPOKWKatxOdcF/gAGkshBrfoNDdeaHGh
// SIG // 5Rj1efVpTY3Znwf07lDIsir8n0igSSfNITT5E44DrJQr
// SIG // YRdNTcN/bat7RekBn9BCTjrM+rg7SFrXP2VS5sXzXg7k
// SIG // jkt24ylx7+kzHcmA1UFPYw63GxqhBsE64j0gWIHmP2iy
// SIG // QHYquj3nS3gN6o8J9PV3WOcFerDcOgk8Mw970eJ7SM1v
// SIG // mqC0pnLehHjYFaENPvoEUy9lslGV/H6hghewMIIXrAYK
// SIG // KwYBBAGCNwMDATGCF5wwgheYBgkqhkiG9w0BBwKggheJ
// SIG // MIIXhQIBAzEPMA0GCWCGSAFlAwQCAQUAMIIBWgYLKoZI
// SIG // hvcNAQkQAQSgggFJBIIBRTCCAUECAQEGCisGAQQBhFkK
// SIG // AwEwMTANBglghkgBZQMEAgEFAAQgttXIJM1MIUD2j04L
// SIG // ARuhuBFBs4q6IwqMEXORVBQEmvkCBmdJ1noCqhgTMjAy
// SIG // NDEyMDkyMTA1NDMuNTIxWjAEgAIB9KCB2aSB1jCB0zEL
// SIG // MAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24x
// SIG // EDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jv
// SIG // c29mdCBDb3Jwb3JhdGlvbjEtMCsGA1UECxMkTWljcm9z
// SIG // b2Z0IElyZWxhbmQgT3BlcmF0aW9ucyBMaW1pdGVkMScw
// SIG // JQYDVQQLEx5uU2hpZWxkIFRTUyBFU046MzYwNS0wNUUw
// SIG // LUQ5NDcxJTAjBgNVBAMTHE1pY3Jvc29mdCBUaW1lLVN0
// SIG // YW1wIFNlcnZpY2WgghH+MIIHKDCCBRCgAwIBAgITMwAA
// SIG // AfdYIHUEyvvC9AABAAAB9zANBgkqhkiG9w0BAQsFADB8
// SIG // MQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3Rv
// SIG // bjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWlj
// SIG // cm9zb2Z0IENvcnBvcmF0aW9uMSYwJAYDVQQDEx1NaWNy
// SIG // b3NvZnQgVGltZS1TdGFtcCBQQ0EgMjAxMDAeFw0yNDA3
// SIG // MjUxODMxMDZaFw0yNTEwMjIxODMxMDZaMIHTMQswCQYD
// SIG // VQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4G
// SIG // A1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0
// SIG // IENvcnBvcmF0aW9uMS0wKwYDVQQLEyRNaWNyb3NvZnQg
// SIG // SXJlbGFuZCBPcGVyYXRpb25zIExpbWl0ZWQxJzAlBgNV
// SIG // BAsTHm5TaGllbGQgVFNTIEVTTjozNjA1LTA1RTAtRDk0
// SIG // NzElMCMGA1UEAxMcTWljcm9zb2Z0IFRpbWUtU3RhbXAg
// SIG // U2VydmljZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCC
// SIG // AgoCggIBANDnR0wTaJuv7lymhCj/azyE5E+kMRddbY8w
// SIG // dDZNW8g6T6xUx4Wt4ccEnU3K/GNGt5OhEJcKsukTs+Nn
// SIG // tEeXg1vnQqEGqYqQyBVDmKd6DbqsF/8XqQExJGNezMlx
// SIG // ceq0FtjXFlCVt0KNgLidBzrW5UqSLUGTxph5xqpLfwwe
// SIG // ORcMZOlaEr8TXECoShE5Ls67fFOg0XHEJtRXYZjyoA84
// SIG // HHwzzOaPhp824jLustOvQOBB5izJpHnEpFbwZnGfFZ8x
// SIG // R0w5Bi3aZw1eRV41TmwIG0jNHJ6mEhn0ae1RhwUasqLH
// SIG // L0eG3EPglfaQ42yekua2Z9bgPIUYY9PR7N9x0Xr7eKFg
// SIG // FWBiLYBLBvgawmG6YFjAxCFZwID2RIjwGiPMARnphOH3
// SIG // hJLs+0wMIJEQXFMy4EOLrz6kQ9QPiZLduvqQ6lmEp9DA
// SIG // PI9M2nEJPavwL3Ij1w/SLdns/pqhM4BUUbCRi7XH/R5L
// SIG // LyvCbHeiOcxUoZaouW6c39WODTojToeUMFtaSLwOYq5W
// SIG // pe6hYZAHnnmapqKfPrjcWV8RQkBt0d7OaV1vPRYgofa5
// SIG // l61ajgsIHFxSCUAEJJZSrCPlCahqva5kQASc+ZRykxWJ
// SIG // hcHDOdillozcd8+qHcM9ofrMWsXsE6HvRqrQ8d/2lPsq
// SIG // jUXAfMNLUl1H/spTeLpOcRxKS6cfmTTbAgMBAAGjggFJ
// SIG // MIIBRTAdBgNVHQ4EFgQU30akMz95vT2Vri39afP5nhX5
// SIG // JpgwHwYDVR0jBBgwFoAUn6cVXQBeYl2D9OXSZacbUzUZ
// SIG // 6XIwXwYDVR0fBFgwVjBUoFKgUIZOaHR0cDovL3d3dy5t
// SIG // aWNyb3NvZnQuY29tL3BraW9wcy9jcmwvTWljcm9zb2Z0
// SIG // JTIwVGltZS1TdGFtcCUyMFBDQSUyMDIwMTAoMSkuY3Js
// SIG // MGwGCCsGAQUFBwEBBGAwXjBcBggrBgEFBQcwAoZQaHR0
// SIG // cDovL3d3dy5taWNyb3NvZnQuY29tL3BraW9wcy9jZXJ0
// SIG // cy9NaWNyb3NvZnQlMjBUaW1lLVN0YW1wJTIwUENBJTIw
// SIG // MjAxMCgxKS5jcnQwDAYDVR0TAQH/BAIwADAWBgNVHSUB
// SIG // Af8EDDAKBggrBgEFBQcDCDAOBgNVHQ8BAf8EBAMCB4Aw
// SIG // DQYJKoZIhvcNAQELBQADggIBADdGo2nyC3i+kkCDCDAF
// SIG // zNUHesWqHItpjq6UfLylssk7C92/NwO1xi4gG0MU66p1
// SIG // 71VlnjbLeWEA/LGjvlE4DiyXU3X1AA4S16CvkZcI353Y
// SIG // piCU/TB/bVGFy8yVyoWTNPaLj8DbK5/GDiyKXQIuUz8j
// SIG // fApddThmUpT/a/CZ76JltNAKCeD5fa5YNBuZXEJJwF6h
// SIG // 2vZ0HVqdWcV6jXftCbCppUfLXADV99wpTPTZ2gpSRMS0
// SIG // B4inh1FFrasizJeuU1usETO15Re2Pj05wvHbjVp+Li54
// SIG // Pjjf2d/RjuqgY+yBGcaKuKN2rxIfW2uN1FOk4M1WWgZv
// SIG // FWgNMEsFHv6aqUzmBVjetly94JfyQtqc3yD8T+ul30Sy
// SIG // MWn4wVV5vClQ59nDC/SL0StNrPeNWOfkUeIEgDoS4kEO
// SIG // gNN1TUbqfrKTGtJPl0zwIvtmjB+cWtWY2/yvLvX/TNOV
// SIG // NP21DCVyQz/vsrFqSW1UQ4hxu7M2nGvq9x4lD40CckJd
// SIG // jYjnGExlfw3C6ywgStsxudNxRm9ODeSn9dF4AMBWl5aH
// SIG // eQfXiofeT51ysdizQYC8BvOWp5YYRscQUOZhbCRpAZ9D
// SIG // 2T7QM2cn6/eqsc6adqR/QySXIygg6zJmc4l2s6WuVVTd
// SIG // +gjtZA1OAAZEmE1zjPEZiV7kJu5lBd21po/oYwCW+Kc+
// SIG // oU+VMIIHcTCCBVmgAwIBAgITMwAAABXF52ueAptJmQAA
// SIG // AAAAFTANBgkqhkiG9w0BAQsFADCBiDELMAkGA1UEBhMC
// SIG // VVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcT
// SIG // B1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jw
// SIG // b3JhdGlvbjEyMDAGA1UEAxMpTWljcm9zb2Z0IFJvb3Qg
// SIG // Q2VydGlmaWNhdGUgQXV0aG9yaXR5IDIwMTAwHhcNMjEw
// SIG // OTMwMTgyMjI1WhcNMzAwOTMwMTgzMjI1WjB8MQswCQYD
// SIG // VQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4G
// SIG // A1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0
// SIG // IENvcnBvcmF0aW9uMSYwJAYDVQQDEx1NaWNyb3NvZnQg
// SIG // VGltZS1TdGFtcCBQQ0EgMjAxMDCCAiIwDQYJKoZIhvcN
// SIG // AQEBBQADggIPADCCAgoCggIBAOThpkzntHIhC3miy9ck
// SIG // eb0O1YLT/e6cBwfSqWxOdcjKNVf2AX9sSuDivbk+F2Az
// SIG // /1xPx2b3lVNxWuJ+Slr+uDZnhUYjDLWNE893MsAQGOhg
// SIG // fWpSg0S3po5GawcU88V29YZQ3MFEyHFcUTE3oAo4bo3t
// SIG // 1w/YJlN8OWECesSq/XJprx2rrPY2vjUmZNqYO7oaezOt
// SIG // gFt+jBAcnVL+tuhiJdxqD89d9P6OU8/W7IVWTe/dvI2k
// SIG // 45GPsjksUZzpcGkNyjYtcI4xyDUoveO0hyTD4MmPfrVU
// SIG // j9z6BVWYbWg7mka97aSueik3rMvrg0XnRm7KMtXAhjBc
// SIG // TyziYrLNueKNiOSWrAFKu75xqRdbZ2De+JKRHh09/SDP
// SIG // c31BmkZ1zcRfNN0Sidb9pSB9fvzZnkXftnIv231fgLrb
// SIG // qn427DZM9ituqBJR6L8FA6PRc6ZNN3SUHDSCD/AQ8rdH
// SIG // GO2n6Jl8P0zbr17C89XYcz1DTsEzOUyOArxCaC4Q6oRR
// SIG // RuLRvWoYWmEBc8pnol7XKHYC4jMYctenIPDC+hIK12Nv
// SIG // DMk2ZItboKaDIV1fMHSRlJTYuVD5C4lh8zYGNRiER9vc
// SIG // G9H9stQcxWv2XFJRXRLbJbqvUAV6bMURHXLvjflSxIUX
// SIG // k8A8FdsaN8cIFRg/eKtFtvUeh17aj54WcmnGrnu3tz5q
// SIG // 4i6tAgMBAAGjggHdMIIB2TASBgkrBgEEAYI3FQEEBQID
// SIG // AQABMCMGCSsGAQQBgjcVAgQWBBQqp1L+ZMSavoKRPEY1
// SIG // Kc8Q/y8E7jAdBgNVHQ4EFgQUn6cVXQBeYl2D9OXSZacb
// SIG // UzUZ6XIwXAYDVR0gBFUwUzBRBgwrBgEEAYI3TIN9AQEw
// SIG // QTA/BggrBgEFBQcCARYzaHR0cDovL3d3dy5taWNyb3Nv
// SIG // ZnQuY29tL3BraW9wcy9Eb2NzL1JlcG9zaXRvcnkuaHRt
// SIG // MBMGA1UdJQQMMAoGCCsGAQUFBwMIMBkGCSsGAQQBgjcU
// SIG // AgQMHgoAUwB1AGIAQwBBMAsGA1UdDwQEAwIBhjAPBgNV
// SIG // HRMBAf8EBTADAQH/MB8GA1UdIwQYMBaAFNX2VsuP6KJc
// SIG // YmjRPZSQW9fOmhjEMFYGA1UdHwRPME0wS6BJoEeGRWh0
// SIG // dHA6Ly9jcmwubWljcm9zb2Z0LmNvbS9wa2kvY3JsL3By
// SIG // b2R1Y3RzL01pY1Jvb0NlckF1dF8yMDEwLTA2LTIzLmNy
// SIG // bDBaBggrBgEFBQcBAQROMEwwSgYIKwYBBQUHMAKGPmh0
// SIG // dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9wa2kvY2VydHMv
// SIG // TWljUm9vQ2VyQXV0XzIwMTAtMDYtMjMuY3J0MA0GCSqG
// SIG // SIb3DQEBCwUAA4ICAQCdVX38Kq3hLB9nATEkW+Geckv8
// SIG // qW/qXBS2Pk5HZHixBpOXPTEztTnXwnE2P9pkbHzQdTlt
// SIG // uw8x5MKP+2zRoZQYIu7pZmc6U03dmLq2HnjYNi6cqYJW
// SIG // AAOwBb6J6Gngugnue99qb74py27YP0h1AdkY3m2CDPVt
// SIG // I1TkeFN1JFe53Z/zjj3G82jfZfakVqr3lbYoVSfQJL1A
// SIG // oL8ZthISEV09J+BAljis9/kpicO8F7BUhUKz/AyeixmJ
// SIG // 5/ALaoHCgRlCGVJ1ijbCHcNhcy4sa3tuPywJeBTpkbKp
// SIG // W99Jo3QMvOyRgNI95ko+ZjtPu4b6MhrZlvSP9pEB9s7G
// SIG // dP32THJvEKt1MMU0sHrYUP4KWN1APMdUbZ1jdEgssU5H
// SIG // LcEUBHG/ZPkkvnNtyo4JvbMBV0lUZNlz138eW0QBjloZ
// SIG // kWsNn6Qo3GcZKCS6OEuabvshVGtqRRFHqfG3rsjoiV5P
// SIG // ndLQTHa1V1QJsWkBRH58oWFsc/4Ku+xBZj1p/cvBQUl+
// SIG // fpO+y/g75LcVv7TOPqUxUYS8vwLBgqJ7Fx0ViY1w/ue1
// SIG // 0CgaiQuPNtq6TPmb/wrpNPgkNWcr4A245oyZ1uEi6vAn
// SIG // Qj0llOZ0dFtq0Z4+7X6gMTN9vMvpe784cETRkPHIqzqK
// SIG // Oghif9lwY1NNje6CbaUFEMFxBmoQtB1VM1izoXBm8qGC
// SIG // A1kwggJBAgEBMIIBAaGB2aSB1jCB0zELMAkGA1UEBhMC
// SIG // VVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcT
// SIG // B1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jw
// SIG // b3JhdGlvbjEtMCsGA1UECxMkTWljcm9zb2Z0IElyZWxh
// SIG // bmQgT3BlcmF0aW9ucyBMaW1pdGVkMScwJQYDVQQLEx5u
// SIG // U2hpZWxkIFRTUyBFU046MzYwNS0wNUUwLUQ5NDcxJTAj
// SIG // BgNVBAMTHE1pY3Jvc29mdCBUaW1lLVN0YW1wIFNlcnZp
// SIG // Y2WiIwoBATAHBgUrDgMCGgMVAG9vCgxv8V2zQY5jO/56
// SIG // sN24KxDmoIGDMIGApH4wfDELMAkGA1UEBhMCVVMxEzAR
// SIG // BgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1v
// SIG // bmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlv
// SIG // bjEmMCQGA1UEAxMdTWljcm9zb2Z0IFRpbWUtU3RhbXAg
// SIG // UENBIDIwMTAwDQYJKoZIhvcNAQELBQACBQDrAYODMCIY
// SIG // DzIwMjQxMjA5MTQ1NjAzWhgPMjAyNDEyMTAxNDU2MDNa
// SIG // MHcwPQYKKwYBBAGEWQoEATEvMC0wCgIFAOsBg4MCAQAw
// SIG // CgIBAAICGJsCAf8wBwIBAAICFCUwCgIFAOsC1QMCAQAw
// SIG // NgYKKwYBBAGEWQoEAjEoMCYwDAYKKwYBBAGEWQoDAqAK
// SIG // MAgCAQACAwehIKEKMAgCAQACAwGGoDANBgkqhkiG9w0B
// SIG // AQsFAAOCAQEAQDgcQdh+yUteWT8sIB08BLpZJTn5O9Ae
// SIG // 4Wx2zt3wH1uzZbAvIur+WRfe557c0PypNClsGlIqQc8j
// SIG // vYNrdU6csPpkw/dXvkHvDKzG7OXKP8F+7cmiIF4TgDwF
// SIG // 0e7rO2lItmhEQIiX8cf2fV2Oj2+kys0OqdLt7ketlpMZ
// SIG // POes83RCC5v+vXbHWGhEbADHBZh7jf6BHOSeFAKQFM7P
// SIG // D7/09UvTthz7+2BmRwyp56tkovBQZxXcFupTz9lJ4fYL
// SIG // gEB6lpvnibHJH+80SW8Q6camzMHg9IS+u89Apf5/afta
// SIG // c8kDmsAwVNL30BxOnhFonvYE1W7X9tJQjifDPjlMf5v6
// SIG // GzGCBA0wggQJAgEBMIGTMHwxCzAJBgNVBAYTAlVTMRMw
// SIG // EQYDVQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQHEwdSZWRt
// SIG // b25kMR4wHAYDVQQKExVNaWNyb3NvZnQgQ29ycG9yYXRp
// SIG // b24xJjAkBgNVBAMTHU1pY3Jvc29mdCBUaW1lLVN0YW1w
// SIG // IFBDQSAyMDEwAhMzAAAB91ggdQTK+8L0AAEAAAH3MA0G
// SIG // CWCGSAFlAwQCAQUAoIIBSjAaBgkqhkiG9w0BCQMxDQYL
// SIG // KoZIhvcNAQkQAQQwLwYJKoZIhvcNAQkEMSIEICHWvZq8
// SIG // td47mOYCa2V9/7f0ALj3V4FDxDNji++oX1suMIH6Bgsq
// SIG // hkiG9w0BCRACLzGB6jCB5zCB5DCBvQQgIdqY2mt3GtHn
// SIG // GLobutLmBz/yCpz23nW1UCeUqCB+WeIwgZgwgYCkfjB8
// SIG // MQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3Rv
// SIG // bjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWlj
// SIG // cm9zb2Z0IENvcnBvcmF0aW9uMSYwJAYDVQQDEx1NaWNy
// SIG // b3NvZnQgVGltZS1TdGFtcCBQQ0EgMjAxMAITMwAAAfdY
// SIG // IHUEyvvC9AABAAAB9zAiBCDkJrpwTCQI7UYEa39UKO0n
// SIG // AxYo/jcIuQKIe1hjcDBLHTANBgkqhkiG9w0BAQsFAASC
// SIG // AgB2dJWBtnazV+pZywKstQQyIz6sNjn+9UlcA7AbxAHV
// SIG // PPNRiT9HGSSWTAW9PJhoGq5T6l0sG/AJfv0Dl96aobn+
// SIG // NvsBNE2QR5TumHei/t7A3lAnAUjLZGEV8BiZAXFPqEu/
// SIG // QjESDw9takTnP95ZIQJv2VGjioHLTs98UfJc2+k/4eIr
// SIG // PrdUnEfZloyZ26sKhnxrwJf6Kl/q/9VMxGa4809wwxgQ
// SIG // 4aCxdU3sSx/itDZJxq8+UcagQvF/VDgA6vYJ0GRZW29S
// SIG // ufIKfVwFNQW7zz+1CGTWzGwbWbiXwK9NJszfxBJQ8cKY
// SIG // 5JiDSMoNDenrXQMWRCM/J0T0izsat26Wm4N/pDtImo0h
// SIG // patrLIPufi4bWo666wC1MGUv+djFE2Ridg/cSBZgpr/7
// SIG // +aYYZDZ4TNeSIV7VF4J2Bs6DizDBphGbJE1XEOzLlSAx
// SIG // nBncpBZut8nW90SvmacZ0rNUWgVO8uC8elsYcy0M7Fld
// SIG // zrViapFyDDMU5D8boj7LWrUDLkLLF1C7iVhgfDHesnGR
// SIG // H0p2F6+MZxjbbdMcyMXEBE5l233V2DgQZTaKvkR69UeG
// SIG // tsyHERUugpd9ZgYcDT2fVZtmI5Ro/0OrTAozKsWx7mwR
// SIG // +FcXu6pGCb+LiFBySrVVPeh+XKj3wffEA2mZ5CxwwPQd
// SIG // Zw+TFCpi0sWZ+v0LsNvTRWTA9w==
// SIG // End signature block
